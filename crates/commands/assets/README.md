# Quick Reference: Autowirable DI System and Wiring Modifiers

This directory contains the Dependency Injection (DI) framework scaffolded by the `reflections` CLI tool. The framework uses Foundry's `StdConfig` system for:
1. Environment configuration switching (debug / production).
2. Automated contract deployment and wiring through modifiers (`autowire`, `proxywire`, `configwire`).
3. Deterministic contract address computation via `Sources.Source`.
4. Retrieval of deployed contract addresses through `autowired()` functions.

## About Reflections CLI

The `reflections` CLI tool provides two main commands:

- **`reflections init`** - Scaffolds this entire DI framework into your project's `scripts/reflections/di/` directory
  - Copies all framework files (Autowirable, interfaces, configurations, wiring logic)
  - Applies your project's `remappings.txt` to rewrite import paths automatically
  - Adds framework directory to `.gitignore` (regenerated on each init)

- **`reflections generate`** - Generates the `Sources.s.sol` library from your contracts
  - Discovers all contracts in your `src/` directory
  - Creates an enum with all contract types
  - Generates helper functions (`toCreationCode()`, `toString()`, `toSalt()`)
  - Output: `scripts/reflections/di/libraries/Sources.s.sol`

### Typical Workflow

```bash
# 1. Initialize the DI framework (run once or when updating)
reflections init

# 2. Generate Sources library from your contracts
reflections generate

# 3. Write deployment scripts extending Autowirable
# 4. Run your scripts with Forge
forge script script/Deploy.s.sol --rpc-url $RPC --broadcast
```

### Import Path Remapping

The framework respects your project's `remappings.txt`. When running `reflections init`, all Solidity imports are automatically rewritten based on your remappings:

```txt
# Example remappings.txt
@openzeppelin/=lib/openzeppelin-contracts/
forge-std/=lib/forge-std/src/
src/=src/
zksync-os/=lib/zksync-os/contracts/
```

This transforms framework imports:
- `@openzeppelin/contracts/...` → `lib/openzeppelin-contracts/contracts/...`
- `forge-std/...` → `lib/forge-std/src/...`
- `zksync-os/...` → `lib/zksync-os/contracts/...` (for Matter Labs dependencies)

**Note:** The framework templates use `zksync-os/` prefix for example contracts from [matter-labs/zksync-os](https://github.com/matter-labs/zksync-os). Add a corresponding remapping in your `remappings.txt` to point to where you've installed these dependencies.

---
## 1. Base Class: `Autowirable`

All deployment scripts inherit from `Autowirable`, which provides:
- Automatic wiring system setup
- Modifiers for contract binding
- Functions to retrieve deployed contract addresses

Configuration is loaded automatically (DEBUG mode by default) when creating `Autowirable`.

### When to Use
Inherit from `Autowirable` in all deployment scripts:

### Example
```solidity
contract MyDeployScript is Autowirable {
    function run() public { /* ... */ }
}
```

---
## 2. Sources (`Sources.Source`)

`Sources.Source` is an enum where each variant corresponds to a contract/deployment type defined in your project. Sources have helper methods (e.g., `toSalt()`, `toString()`) used for deterministic CREATE2 addressing and configuration identification.

**Note:** This enum is auto-generated by running `reflections generate` based on your project's contracts.

---
## 3. Wiring Modifiers

### `autowire(Sources.Source source)`
Deploys a contract directly with a deterministic address.

### `proxywire(Sources.Source source)`
Deploys a TransparentUpgradeableProxy for the given source.

### `configwire(IConfiguration configContract)`
Executes a configuration contract that can deploy multiple related contracts.

### `accountwire(string memory nickname)`
Deploys a named ModularSmartAccount with the specified nickname.

### `nickwire(Sources.Source source, ShortString nickname)`
Deploys a contract with a specified nickname to enable multiple instances.

### Purpose
Automates contract deployment and saves addresses to configuration for subsequent use.

### Example (from deployment script)
```solidity
function run()
    public
    proxywire(Sources.Source.EOAKeyValidator)
    proxywire(Sources.Source.SessionKeyValidator)
    proxywire(Sources.Source.WebAuthnValidator)
    configwire(guardianExecutorConfig)
    configwire(recoveryConfig)
    configwire(eip4337FactoryConfig)
    accountwire(ALICE_SMART_ACC)
{
    // Inside the function body, contracts are already deployed and accessible via autowired()
}
```

---
## 4. `autowired()` Functions

### `autowired(Sources.Source source)`
Retrieves the address of a contract deployed via `autowire`.

### `autowired(Sources.Source source, string memory nickname)`
Retrieves the address of a contract with a specified nickname (for proxies or named accounts).

### Usage Examples
```solidity
// Get address of a regular contract
address beacon = autowired(Sources.Source.UpgradeableBeacon);

// Get proxy address for a specific module
address eoaValidator = autowired(
    Sources.Source.TransparentUpgradeableProxy, 
    Sources.Source.EOAKeyValidator.toString()
);

// Get address of a named account
address aliceAccount = autowired(Sources.Source.ModularSmartAccount, ALICE_SMART_ACC);
```

---
## 5. Configuration Contracts

For complex deployments, create specialized configuration contracts implementing the `IConfiguration` interface. These allow grouping related deployments.

### Examples:
- `Eip4337FactoryConfiguration` - Deploys EIP-4337 factory and related components
- `GuardianExecutorConfiguration` - Deploys Guardian Executor and its proxy
- `GuardianBasedRecoveryExecutorConfiguration` - Deploys Recovery Executor

### Usage in Scripts:
```solidity
function setUp() public {
    eip4337FactoryConfig = new Eip4337FactoryConfiguration(vm, wiringMechanism, msg.sender);
    guardianExecutorConfig = new GuardianExecutorConfiguration(vm, wiringMechanism, msg.sender);
}

function run() public configwire(eip4337FactoryConfig) configwire(guardianExecutorConfig) {
    // Configurations execute automatically
}
```

---
## 6. Typical Modifier Structure

Recommended order in `run()` / `deploy*()` functions:
1. Wiring modifiers (`autowire`, `proxywire`, `configwire`, `accountwire`, `nickwire`)
2. Inside the body: use `autowired()` to retrieve deployed contract addresses
3. (Optional) logging via `console.log`

---
## 7. Quick Tips

- Use `proxywire` for modules that should be upgradeable via proxy
- Use `autowire` for simple contracts that don't require proxies
- Use `configwire` to group related deployments into configuration contracts
- Use `accountwire` to create named accounts with unique nicknames
- Use `nickwire` when you need multiple instances of the same contract type
- Retrieve addresses via `autowired()` only after declaring corresponding wiring modifiers

---
## 8. Minimal Examples

### Simple Contract Deployment
```solidity
contract SimpleScript is Autowirable {
    function run() public autowire(Sources.Source.EOAKeyValidator) {
        address validator = autowired(Sources.Source.EOAKeyValidator);
        console.log("EOAKeyValidator deployed at:", validator);
    }
}
```

### Proxy Deployment
```solidity
contract ProxyScript is Autowirable {
    function run() public proxywire(Sources.Source.SessionKeyValidator) {
        address proxy = autowired(
            Sources.Source.TransparentUpgradeableProxy,
            Sources.Source.SessionKeyValidator.toString()
        );
        console.log("SessionKeyValidator proxy deployed at:", proxy);
    }
}
```

### Full Example with Configuration
```solidity
contract FullScript is Autowirable {
    GuardianExecutorConfiguration private guardianConfig;
    
    function setUp() public {
        guardianConfig = new GuardianExecutorConfiguration(vm, wiringMechanism, msg.sender);
    }
    
    function run() 
        public 
        proxywire(Sources.Source.EOAKeyValidator)
        configwire(guardianConfig)
        accountwire("TestAccount")
    {
        address eoaProxy = autowired(
            Sources.Source.TransparentUpgradeableProxy,
            Sources.Source.EOAKeyValidator.toString()
        );
        address guardianProxy = autowired(
            Sources.Source.TransparentUpgradeableProxy,
            Sources.Source.GuardianExecutor.toString()
        );
        address account = autowired(Sources.Source.ModularSmartAccount, "TestAccount");
        
        console.log("EOA Validator:", eoaProxy);
        console.log("Guardian Executor:", guardianProxy);
        console.log("Test Account:", account);
    }
}
```

---
## 9. Running Scripts (Example)

(Replace RPC with your endpoint.)
```bash
forge script script/Deploy.s.sol:Deploy --rpc-url $RPC --broadcast -vvvv
```

For a dry-run, omit `--broadcast`.

---
## 10. Common Errors

- `ChooseConfigurationFirst()` - Configuration was not loaded (usually handled automatically in `Autowirable`)
- Errors when calling `autowired()` - Ensure the corresponding wiring modifier was applied
- Invalid nicknames - Ensure you use correct string identifiers for proxies and accounts

---
## 11. Summary

| Modifier/Function | Purpose                             | When to Use                          |
| ----------------- | ----------------------------------- | ------------------------------------ |
| `autowire`        | Deploys contract directly           | For simple contracts without proxies |
| `proxywire`       | Deploys proxy for contract          | For upgradeable modules              |
| `configwire`      | Executes configuration contract     | To group related deployments         |
| `accountwire`     | Deploys named account               | To create ModularSmartAccount        |
| `nickwire`        | Deploys contract with nickname      | For multiple instances of same type  |
| `autowired`       | Retrieves deployed contract address | To access addresses after deployment |

---
## 12. Reflections CLI Commands Reference

### `reflections init [OPTIONS]`
Scaffolds the DI framework into your project.

**Options:**
- `--clean` - Remove `.gitmodules` and `lib/` directory before initializing
- `--config-location <CONFIG_LOCATION>` - Specify config location (foundry or reflections)

**What it does:**
- Copies all framework files from the Reflections CLI assets
- Applies your project's `remappings.txt` to rewrite import paths
- Creates/updates `.gitignore` to exclude the framework directory

### `reflections generate [OPTIONS]`
Generates the Sources library from your contracts.

**Options:**
- `-c, --contracts-dir <DIR>` - Path to contracts directory (default: `src`)
- `-o, --output <FILE>` - Output file path (default: `scripts/reflections/di/libraries/Sources.s.sol`)
- `--library-name <NAME>` - Name of generated library (default: `Sources`)
- `--license <LICENSE>` - SPDX license identifier (default: `MIT`)
- `--solidity-version <VERSION>` - Solidity version pragma (default: `^0.8.0`)

**What it does:**
- Scans your contracts directory for Solidity files
- Extracts all contract, library, and interface definitions
- Generates `Sources.s.sol` with:
  - `Source` enum with all discovered contracts
  - `TransparentUpgradeableProxy` variant for proxy support
  - Helper functions: `toCreationCode()`, `toString()`, `toSalt()`, `getFullNicknamedName()`
  - Constants: `NICKNAMED_PROXY_FLAG`, `EIP4337_FLAG`

### Workflow Integration

```bash
# Initial setup
reflections init

# After adding/modifying contracts
reflections generate

# When updating to new Reflections version
reflections init  # Re-scaffolds framework with latest version
reflections generate  # Regenerates Sources.s.sol
```

If you need extended documentation, sections on creating configuration contracts and the internal implementation of the wiring mechanism can be expanded.

