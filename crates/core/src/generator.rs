//! Generator for Solidity reflection library

use crate::parser::ContractInfo;

pub struct GeneratorOptions {
    pub library_name: String,
    pub license: String,
    pub solidity_version: String,
}

impl Default for GeneratorOptions {
    fn default() -> Self {
        Self {
            library_name: "Sources".to_string(),
            license: "MIT".to_string(),
            solidity_version: "^0.8.0".to_string(),
        }
    }
}

pub fn generate_sources_library(contracts: &[ContractInfo], options: &GeneratorOptions) -> String {
    let imports = generate_imports(contracts);
    let enum_variants = generate_enum_variants(contracts);
    let to_creation_code = generate_to_creation_code(contracts);
    let to_string = generate_to_string(contracts);

    format!(
        r#"// SPDX-License-Identifier: {license}
pragma solidity {version};

import {{ ShortStrings, ShortString }} from "@openzeppelin/contracts/utils/ShortStrings.sol";

{imports}

/// @title {library_name}
/// @notice Auto-generated reflection library for contract metadata
/// @dev Generated by solidity-reflections
library {library_name} {{
    using ShortStrings for ShortString;

    bytes32 public constant NICKNAMED_PROXY_FLAG = keccak256("NICKNAMED_PROXY");
    bytes32 public constant EIP4337_FLAG = keccak256("EIP4337");

    enum Source {{
        NONE,
        TransparentUpgradeableProxy,
{enum_variants}
    }}

    error UnknownMetaArtifact();

    function toSalt(Source metaArtifact) internal pure returns (bytes32) {{
        return keccak256(abi.encodePacked(toString(metaArtifact)));
    }}

    function toSalt(Source metaArtifact, ShortString nickname) internal pure returns (bytes32) {{
        return keccak256(abi.encodePacked(toString(metaArtifact), nickname.toString()));
    }}

    function getFullNicknamedName(Source metaArtifact, ShortString nickname) internal pure returns (string memory) {{
        return string.concat(string.concat(toString(metaArtifact), "_"), nickname.toString());
    }}

{to_creation_code}

{to_string}
}}
"#,
        license = options.license,
        version = options.solidity_version,
        imports = imports,
        library_name = options.library_name,
        enum_variants = enum_variants,
        to_creation_code = to_creation_code,
        to_string = to_string,
    )
}

fn generate_imports(contracts: &[ContractInfo]) -> String {
    contracts
        .iter()
        .map(|c| format!("import {{ {} }} from \"{}\";", c.name, c.import_path))
        .collect::<Vec<_>>()
        .join("\n")
}

fn generate_enum_variants(contracts: &[ContractInfo]) -> String {
    contracts.iter().map(|c| format!("        {}", c.name)).collect::<Vec<_>>().join(",\n")
}

fn generate_to_creation_code(contracts: &[ContractInfo]) -> String {
    let cases = contracts
        .iter()
        .map(|c| {
            format!(
                "        if (metaArtifact == Source.{}) {{\n            return type({}).creationCode;\n        }}",
                c.name, c.name
            )
        })
        .collect::<Vec<_>>()
        .join("\n");

    format!(
        r#"    function toCreationCode(Source metaArtifact) internal pure returns (bytes memory) {{
        if (metaArtifact == Source.TransparentUpgradeableProxy) {{
            revert UnknownMetaArtifact(); // TUP is deployed via new, not CREATE2
        }}
{cases}
        revert UnknownMetaArtifact();
    }}"#,
    )
}

fn generate_to_string(contracts: &[ContractInfo]) -> String {
    let cases = contracts
        .iter()
        .map(|c| {
            format!(
                "        if (metaArtifact == Source.{}) {{\n            return type({}).name;\n        }}",
                c.name, c.name
            )
        })
        .collect::<Vec<_>>()
        .join("\n");

    format!(
        r#"    function toString(Source metaArtifact) internal pure returns (string memory) {{
        if (metaArtifact == Source.TransparentUpgradeableProxy) {{
            return "TransparentUpgradeableProxy";
        }}
{cases}
        revert UnknownMetaArtifact();
    }}"#,
    )
}
